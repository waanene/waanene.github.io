{"meta":{"title":"哇啊NeNe's blog","subtitle":"NeNe的笔记博客","description":"佛系web前端","author":"哇啊NeNe","url":"http://mcer.win"},"pages":[],"posts":[{"title":"Python之for循环套生成器表达式","slug":"Python之for循环套生成器表达式","date":"2018-07-06T15:03:33.000Z","updated":"2018-07-06T15:14:50.503Z","comments":true,"path":"2018/07/06/Python之for循环套生成器表达式/","link":"","permalink":"http://mcer.win/2018/07/06/Python之for循环套生成器表达式/","excerpt":"","text":"12345678910111213def add(x,y): return x+ydef text(): for i in range(4): yield ig = text() #生成器for x in [1, 10, 15] g = (add(x,y) for y in g)print(list(g)) 123456789101112131415...g = text() #生成器for x in [1, 10, 15] g = (add(x,y) for y in g)#----------------------------------------x = 1g = (add(x,y) for y in g)x = 10g = (add(x,y) for y in (add(x,y) for y in g))x = 15g = (add(x,y) for y in (add(x,y) for y in (add(x,y) for y in text())))#---------此间为过程 拆开看即可-----------print(list(g)) 只要遇见 for循环套生成器表达式的就拆开理解","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"}]},{"title":"列表推导式and生成器表达式","slug":"列表推导式and生成器表达式","date":"2018-07-06T12:54:38.000Z","updated":"2018-07-06T14:06:19.838Z","comments":true,"path":"2018/07/06/列表推导式and生成器表达式/","link":"","permalink":"http://mcer.win/2018/07/06/列表推导式and生成器表达式/","excerpt":"","text":"列表推导式1print([i for i in range(10)]) 生成器表达式1234g = (i for i in range(10)print(g)for i in g: print(i) 两种表达式的区别： 1、’[]’与’()’不同 2、返回的值不一样 —生成器表达式不占内存 总结 两个公式 作用有限 语法 [每个元素或者是和元素相关的操作 for 元素 in 可迭代数据类型] #遍历之后挨个处理[满足条件的元素相关的操作 for 元素 in 可迭代数据类型 if 元素相关的条件] #筛选功能栗子：列出30以内能被3整除的数12ret = [i for i in range(30) if i%3 == 0]print(ret) 列出30以内能被3整除的数的平方12ret = [i*i for i in range(30) if i%3 == 0]print(ret) 嵌套列表遍历123mingdan = [[1231],[23211]]ret = [name for lis in mingdan for name in lis if name.count(&apos;1&apos;) == 2]print(ret) 字典推导式将一个字典的key和value对调1234dic1 = &#123;&apos;a&apos;: 10, &apos;b&apos;= 2&#125;#&#123;10:&apos;a&apos;, 2:&apos;b&apos;&#125; new_dic = &#123;dic1[k]:k for k in dic1&#125;print(new_dic) 集合推导式，自带结果去重功能123squared = &#123;x**2 for x in [1, -1 ,2 , -2]&#125;print(squared) 生成器&amp;迭代器的多属于惰性运算，且从头到尾只取一次值（生成器中的数据只能取一次，取完就没有了） Oldboy 9s day14","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"}]},{"title":"Demon哥分享整理2017-2018","slug":"Demon哥分享整理2017-2018","date":"2018-07-06T10:02:55.000Z","updated":"2018-07-06T11:15:51.775Z","comments":true,"path":"2018/07/06/Demon哥分享整理2017-2018/","link":"","permalink":"http://mcer.win/2018/07/06/Demon哥分享整理2017-2018/","excerpt":"目录 首先要说的：感谢Demon哥为我们所做的","text":"目录 首先要说的：感谢Demon哥为我们所做的 cobalstrike模糊处理绕过windows default破冰船 内网渗透工具Linux exploit开发密码攻击工具linux提权工具xss挖掘工具windows提权集合密码储存备忘单漏洞挖掘windows应用程序本地监控xss绕过waf各种远程下载命令内网渗透例子windows内核开发，远程利用从c语言到x86汇编语言x攻击者自动扫描漏洞 Th3inspector Tool 信息自动化收集 反爬虫技术用于寻找ad策略容易受到攻击的脚本一组用于调试csrf和xss攻击的脚本吹笛者，端口转发各种漏洞的payloadweb攻击视频:youtube关注:Penetration Testing in Linuxpowershell混淆独角兽 powershell降权攻击插入内存特权升级和后期开发寻找Flash文件的xssburpsuite入侵者python漏洞扫描器xss攻击确认超越XSS：边缘包含注入躲避沙盒的工具从png到xss吾爱破解工具包吾爱破解虚拟机cobra漏洞扫描器sn1per漏洞扫描器霸道无比的挖洞例子：从反序列化漏洞到掌控帝国：百万美刀的Instagram漏洞渗透Facebook 的思路与发现潮湿工具 提权 DAMPjavasecript 漏洞利用工具PowerShell：如何获取远程计算机上所有已安装软件的列表技术福利 | 通过HTTP进行交互式绑定wmic调用xls后期开发工具Redsails自动混淆工具macro_packwindows域密码抓取xss漏洞工具 内网渗透自动特权升级winpwnage 用于内网提权防止端口被扫描技术owasp web目录扫描器混淆器GalileoOptiva-Framework web扫描器Linux提权审计rundll1132.exe 注册表滥用恶意软件分析过程wmic利用信息收集器-vanquishpowershell学习网站Hack the boxAPT常见的利用手法GhostTunnel攻击在线识别漏洞补丁meterpreter利用powershell进行内网信息收集日志分析过程逆向学习线路隐藏Metasploit Shellcode以逃避Windows Defender红色团队工具SSRF漏洞文档linux exploit大全分析js，得到越权Hack文章Hack学习http访问控制推荐的国外论坛Hack the box解题视频 快速搭建环境docker搭建的：http://vulhub.org/#/environments/dns/dns-zone-transfer/vmbox搭建：https://www.vulnhub.com/ Demon哥的博客：http://www.ggsec.cn即刻安全官网：http://www.secist.com/Demon哥的推特与YouTube账号：Demonsec666即刻安全技术交流群：307283889 -----整理人:即刻安全-九世 ----整理最后时间2018年7月6号17点23分","categories":[],"tags":[{"name":"网页收藏","slug":"网页收藏","permalink":"http://mcer.win/tags/网页收藏/"}]},{"title":"Python生成器函数之移动平均值","slug":"Python生成器函数之移动平均值","date":"2018-07-06T09:42:57.000Z","updated":"2018-07-06T12:35:02.693Z","comments":true,"path":"2018/07/06/Python生成器函数之移动平均值/","link":"","permalink":"http://mcer.win/2018/07/06/Python生成器函数之移动平均值/","excerpt":"","text":"生成器函数之移动平均值之骚操作 平均值公式：平均值=总量/个数1234567891011121314151617def average(): sum = 0 count = 0 avg = 0 while True: num = yield avg sum += num count += 1 avg = sum / countavg_g = average()avg_g.__next__()print(avg_g.send(10))avg_g.__next__()print(avg_g.send(20))avg_g.__next__()print(avg_g.send(30)) 为了节省上方代码结尾处的next方法的重调用，通过添加装饰器来省去重复过程1234567891011121314151617181920212223def init(func): def inner(*args,**kwargs): g = func(*args,**kwargs) g.__next__() #此处优化上方代码结尾__next__方法的重复调用 return g return inner@wappsdef average(): sum = 0 count = 0 avg = 0 while True: num = yield avg sum += num count += 1 avg = sum / countavg_g = average()#avg_g.__next__() #在装饰器中执行了__next__方法print(avg_g.send(10))print(avg_g.send(20))print(avg_g.send(30))","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"}]},{"title":"PytPython迭代器和生成器初识","slug":"PytPython迭代器初识","date":"2018-07-06T07:39:57.000Z","updated":"2018-07-06T09:48:02.816Z","comments":true,"path":"2018/07/06/PytPython迭代器初识/","link":"","permalink":"http://mcer.win/2018/07/06/PytPython迭代器初识/","excerpt":"","text":"迭代器 双下方法：很少直接调用的方法。 一般情况下，是通过其他语法触发的可迭代的 —可迭代协议 含有iter的方法（’iter‘ in dir(数据)）可迭代的一定可以被for循环迭代器协议：含有iter和next方法迭代器一定可以迭代，可迭代的不一定是迭代器，可迭代的通过调用iter()方法就能得到一个迭代器迭代器的贴点： 很方便使用，且只能取所有的数据取一次 节省内存空间 生成器 生成器的本质就是迭代器生成器的表现形式 生成器函数 生成器表达式生成器函数 含有yield关键字的函数就是生成器函数 特点： 调用函数的时候 函数不执行，返回一个生成器 每次调用next方法的时候 会取到一个值 直到取完最后一个，再执行next会报错 12345678910111213def generator(): for i in range(2000000) yield &quot;whoami%s&quot;%ig = generator() #调用生成器函数得到一个生成器ret = g.__next__() #每一次执行g.__next__就是从生成器中取值，预示着生成器函数中的代码继续执行print(ret)num = 0for i in g: num += 1 if num &gt; 50: break print(i) 从生成器中取值的几个方法 next for 数据类型的强制转换↓1234567def generator(): for i in range(2000000) yield &quot;whoami%s&quot;%ig = generator() #调用生成器函数得到一个生成器g.__next__() #每一次执行g.__next__就是从生成器中取值，预示着生成器函数中的代码继续执行print(list(g)) #强转成list列表 但是占内存 1234567891011def generator() print(123) yield 1 print(456) yield 2g = generator()ret = g.__next__()print(&apos;whoami&apos;, ret)ret = g.__next__()print(&apos;whoami&apos;, ret) 123456789101112def generator() print(123) content = yield 1 print(&apos;&gt;&gt;&gt;&gt;&gt;&apos;, content) print(456) yield 2g = generator()ret = g.__next__()print(&apos;whoami&apos;, ret)ret = g.send(&apos;注意此处content&apos;) #send的效果与__next__一样，send将str传给了上方因yield 1暂停处的content变量print(&apos;whoami&apos;, ret) send() 获取下一个值的效果和next的效果基本一致 只是在获取下一个值的时候，给上一个yield的位置传一个数据 (作用是在执行下一个yield 2 之前传一个值到之前一个yield 1 之后) 使用send()的注意事项 第一次使用生成器的时候， 必须是用next获取下一个值 最后一个yield是不能获取到send传来的外部值的，就是最后一个yield是结束语，用来支撑send()方法的调用。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"}]},{"title":"Python装饰器之反向'QA'","slug":"Python装饰器之反向‘QA’","date":"2018-07-05T03:38:29.000Z","updated":"2018-07-05T07:41:49.709Z","comments":true,"path":"2018/07/05/Python装饰器之反向‘QA’/","link":"","permalink":"http://mcer.win/2018/07/05/Python装饰器之反向‘QA’/","excerpt":"","text":"装饰器小姿势：12345678910111213141516171819from functools import wraps #wraps装饰 PS1def wrapper(func): #whoami @wraps(func) #带参数的装饰器 反向获取被装饰函数的函数名 PS2 def inner(*args,**kwargs): ret = func(*args,**kwargs) #被装饰的函数 return ret return inner@wrapper #whoami = wrapper(whoami)def whoami(): &quot;&quot;&quot;我是谁 &quot;&quot;&quot; print(&quot;admin&quot;)ret = whoami() #innerprint(whoami.__name__) #获取被装饰函数whoami()的函数名，如果没有上方PS1 PS2处的引用 将得到的是装饰器内置函数inner的函数名。print(whoami.__doc__) #获取whoami()函数的注释内容","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"}]},{"title":"Python监听文件输入","slug":"Python监听文件输入","date":"2018-07-04T15:57:56.000Z","updated":"2018-07-04T16:11:43.283Z","comments":true,"path":"2018/07/04/Python监听文件输入/","link":"","permalink":"http://mcer.win/2018/07/04/Python监听文件输入/","excerpt":"","text":"12345678910def look(filename): f = open(&apos;filename&apos;, encoding=&apos;utf-8&apos;) while True: line = f.readline() if line.strip(): yield line.strip()g = look(&apos;file&apos;)for i in g: print(&apos;xxx:&apos;,i) 骚操作 oldboy 9s day12","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"}]},{"title":"Rust语言中文社区","slug":"Rust语言中文社区","date":"2018-07-04T14:13:07.000Z","updated":"2018-07-04T15:47:58.218Z","comments":true,"path":"2018/07/04/Rust语言中文社区/","link":"","permalink":"http://mcer.win/2018/07/04/Rust语言中文社区/","excerpt":"","text":"要入坑吗？观望一下 Rust语言中文社区https://rust.cc/Rust语言官网https://www.rust-lang.org/zh-CN/","categories":[],"tags":[{"name":"网页收藏","slug":"网页收藏","permalink":"http://mcer.win/tags/网页收藏/"},{"name":"Rust","slug":"Rust","permalink":"http://mcer.win/tags/Rust/"}]},{"title":"Python生成器初识","slug":"Python生成器初识","date":"2018-07-04T13:50:07.000Z","updated":"2018-07-04T15:51:40.197Z","comments":true,"path":"2018/07/04/Python生成器初识/","link":"","permalink":"http://mcer.win/2018/07/04/Python生成器初识/","excerpt":"","text":"生成器工作原理：边生成数据边处理数据 即内存占用小 12345678def ddos(): for i in range(20000): yield &quot;DDOS数量：%s&quot;%ig = ddos()for i in g: print(i)print(g.__next__()) #单步生成 函数中有yield 关键字的函数就是生成器函数通过调用赋值给g 表示g获得了一个生成器 可重复获得新的g生成器通过for循环i 来调用生辰器函数","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"}]},{"title":"Python装饰器函数初识","slug":"Python装饰器函数初识","date":"2018-07-04T04:19:14.000Z","updated":"2018-07-04T11:36:57.879Z","comments":true,"path":"2018/07/04/Python装饰器函数初识/","link":"","permalink":"http://mcer.win/2018/07/04/Python装饰器函数初识/","excerpt":"","text":"装饰器的形成过程：最简单的装饰器—有返回值的—有一个参数的—万能参数装饰器语法糖：@装饰器函数名 等价于 func = wrapper(func)装饰器的本质：闭包函数开发原则：开放封闭原则 开放：对扩展是开放的 封闭：对修改是封闭的 1234567891011121314151617181920212223242526import time@timer #语法糖 @装饰器函数名def func(a): #被装饰的函数 time.sleep(0.1) #让程序在执行到这个文职的时候停一会儿对应的时间 print(&apos;oheihei&quot;,a) return &apos;ehehe&apos;def timer(f): #装饰器函数 def run_time(*args,**kwargs): start = time.time() #开始时获取当前时间 ret = f(*args,**kwargs) #赋值被装饰的函数的返回值 end = time.time() #结束时获取当前时间 print(end - start) return ret return run_time #注意函数名不能加括号()，不然报错@timer #语法糖 @装饰器函数名def func1(a,b): #被装饰的函数 time.sleep(0.1) #让程序在执行到这个文职的时候停一会儿对应的时间 print(&apos;oheihei&quot;,a,b) return &apos;ehehe&apos;#func = timer(func) #上方语法糖的作用就是等同于此处代码 PS1ret = func(1,2,) #run_time()ret = func(1,b=3)print(ret) 装饰器的作用 — 不想修改函数的调用方式 但是还想在原来的函数前后添加功能timer就是一个装饰器函数，只是对一个函数 有一些装饰作用 装饰器的固定形式：12345678910111213def wrapper(f): #装饰器函数,f是被装饰的函数名，由上方&apos;PS1&apos;处解释关联关系 def run_time(*args,**kwargs): print(&quot;在被装饰函数之前要做的事情&quot;) ret = f(*args,**kwargs) #赋值被装饰的函数的返回值 print(&quot;在被装饰函数之后要做的事情&quot;) return ret return run_time #注意函数名不能加括号()，不然报错@wrapper #语法糖 @装饰器函数名def func1(a,b): #被装饰的函数 time.sleep(0.1) #让程序在执行到这个文职的时候停一会儿对应的时间 print(&apos;oheihei&quot;,a,b) return &apos;ehehe&apos; 固定模式默写： 1234567891011def wrapper(func): #whoami def inner(*args,**kwargs): ret = func(*args,**kwargs) #被装饰的函数 return ret return inner@wrapper #whoami = wrapper(whoami)def whoami(): print(&quot;admin&quot;)ret = whoami() #inner 123456正常参数调用： 参数x ===========&gt;用户 函数a &lt;=========== 返回值r 1234567添加装饰器函数后的调用： 参数x 参数x ===========&gt; ===========&gt;用户 装饰器函数b 函数a &lt;=========== &lt;=========== 返回值r 返回值r 传参的*args 现象解释：接收就聚合调用就打散 Oldboy 9s day11","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"}]},{"title":"Python之闭包","slug":"Python之闭包","date":"2018-07-03T13:21:20.000Z","updated":"2018-07-03T13:27:54.462Z","comments":true,"path":"2018/07/03/Python之闭包/","link":"","permalink":"http://mcer.win/2018/07/03/Python之闭包/","excerpt":"","text":"什么才是闭包：嵌套函数，并且行为构成内部函数调用外部函数的变量。 栗子：123456789def wtf(): a = 1 def whoami(): print(a) print(whoami.__closure__)wtf()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"}]},{"title":"HTML网页跳转标签的使用","slug":"HTML网页跳转标签的使用","date":"2018-07-01T13:44:03.000Z","updated":"2018-07-01T13:52:34.271Z","comments":true,"path":"2018/07/01/HTML网页跳转标签的使用/","link":"","permalink":"http://mcer.win/2018/07/01/HTML网页跳转标签的使用/","excerpt":"","text":"HTML网页跳转的实现例如：https:www.123456hd.com 网站首页的跳转效果 html文件头部 使用meta http-equiv属性就可以达到效果。 12&lt;!--2秒后跳转到指定网址，注意引号的使用--&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2;URL=https://指定网址&quot;&gt; #refresh 为刷新跳转 #content 为倒计时","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"http://mcer.win/tags/html5/"},{"name":"web前端","slug":"web前端","permalink":"http://mcer.win/tags/web前端/"}]},{"title":" Ubuntu14.04修改ssh端口","slug":"Ubuntu14-04修改ssh端口","date":"2018-06-30T10:16:24.000Z","updated":"2018-07-06T09:58:03.062Z","comments":true,"path":"2018/06/30/Ubuntu14-04修改ssh端口/","link":"","permalink":"http://mcer.win/2018/06/30/Ubuntu14-04修改ssh端口/","excerpt":"","text":"Linux中SSH默认端口为22，为了安全考虑，我们有必要对22端口进行修改，现修改端口为60000；修改方法如下：在/etc/ssh/sshd_config中找到Port 22，将其修改为60000,或使用/usr/sbin/sshd -p 60000指定端口。 如果用户想让22和60000端口同时开放，只需在/etc/ssh/sshd_config增加一行内容如下：12345[root@localhost /]# vi /etc/ssh/sshd_configPort 22Port 60000保存并退出[root@localhost /]#service ssh restart","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://mcer.win/tags/Linux/"},{"name":"配置","slug":"配置","permalink":"http://mcer.win/tags/配置/"}]},{"title":"开博第二天小日记","slug":"开博第二天小日记","date":"2018-06-28T15:47:20.000Z","updated":"2018-06-28T15:52:00.449Z","comments":true,"path":"2018/06/28/开博第二天小日记/","link":"","permalink":"http://mcer.win/2018/06/28/开博第二天小日记/","excerpt":"","text":"老男孩9s看到day3明天继续看day4 JavaScript看到这里了https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499190108eec0bdf14e704a09935cd112e501e31a000#0 然后晚上Ubuntu14.0服务器上线了 环境还需要慢慢配置python虚拟环境已经配置好了MySQL-server装好了没配置完 只能本地访问 抽空弄外连 睡觉睡觉 狗命要紧","categories":[],"tags":[{"name":"日记","slug":"日记","permalink":"http://mcer.win/tags/日记/"}]},{"title":"ubuntu14.04 下安装mysql","slug":"Ubuntu14-04-下安装mysql","date":"2018-06-28T15:39:38.000Z","updated":"2018-07-06T14:07:21.741Z","comments":true,"path":"2018/06/28/Ubuntu14-04-下安装mysql/","link":"","permalink":"http://mcer.win/2018/06/28/Ubuntu14-04-下安装mysql/","excerpt":"","text":"1.1sudo apt-get install mysql-server 2.测试是否安装成功12ps aux |grep mysqlmysql -u root -p 3.允许远程访问设置12345678910111213141516# sudo service mysql stop# sudo vim /etc/mysql/my.conf# #注释 bind_address=127.0.0.1# 重启mysql： sudo service mysql restart# 登录mysql： mysql -u rot -p# 切换数据库 use mysql;# 允许现有用户的远程访问 update user set host=&apos;%&apos; where user=&apos;root&apos; and host =&apos;localhost&apos;;# 退出数据库，重启数据库 exit; sudo service mysql restart; 4.数据库文件的迁移1234567891011121314151617181920212223242526# sudo service mysql stop #迁移前必须停止mysql# 创建mysql 存放的目标文件夹 sudo /mnt/mysqldata# 修改所属用户和用户组 sudo chown -R mysql:mysql /mnt/mysqldata# 修改权限 sudo chmod -R 700 /mnt/mysqldata# 迁移文件 su root; cp -a /var/lib/mysql/* /mnt/mysqldata/# 修改配置文件 sudo vim /etc/mysql/my.conf# datadir = /mnt/mysqldata# 以上mysql 配置完毕，在ubuntu还有些敏感操作受到了 apparmor.d 的限制，mysql也受到了限制，# sudo vim /etc/apparmor.d/usr.sbin.mysqld···············# /var/lib/mysql/ r, # /var/lib/mysql/** rwk,···············# 重新启动apparmor 和mysql# sudo service apparmor reload# sudo service mysql start","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://mcer.win/tags/mysql/"},{"name":"Linux","slug":"Linux","permalink":"http://mcer.win/tags/Linux/"},{"name":"配置","slug":"配置","permalink":"http://mcer.win/tags/配置/"}]},{"title":"Ubuntu下virtualenv 的安装及使用","slug":"Ubuntu下virtualenv-的安装及使用","date":"2018-06-28T15:19:50.000Z","updated":"2018-07-06T14:07:31.574Z","comments":true,"path":"2018/06/28/Ubuntu下virtualenv-的安装及使用/","link":"","permalink":"http://mcer.win/2018/06/28/Ubuntu下virtualenv-的安装及使用/","excerpt":"","text":"首先，用pip安装virtualenv：1$ pip3 install virtualenv 然后，假定要开发一个新的项目，需要一套独立的Python运行环境，可以这么做： 第一步，创建目录： 12$ mkdir myproject$ cd myproject/ 第二步，创建一个独立的Python运行环境，命名为webpy3： 1234$ virtualenv --no-site-packages webpy3undefinedInstalling setuptools, pip, wheel...done. 命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数–no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。 新建的Python环境被放到当前目录下的webpy3目录。有了webpy3这个Python环境，可以用source进入该环境：123$ cd webpy3/bin/~/webpy3/bin# source activate(webpy3) root@MyCloudServer:~/myproject/webpy3/bin# 退出当前的webpy3环境，使用deactivate命令 12(webpy3) root@MyCloudServer:~/myproject/webpy3/bin# deactivateroot@MyCloudServer:~/myproject/webpy3/bin#","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://mcer.win/tags/Linux/"},{"name":"配置","slug":"配置","permalink":"http://mcer.win/tags/配置/"}]},{"title":"Ubuntu14.04上安装pip的方法","slug":"Ubuntu14-04上安装pip的方法","date":"2018-06-28T15:00:36.000Z","updated":"2018-07-06T09:57:24.399Z","comments":true,"path":"2018/06/28/Ubuntu14-04上安装pip的方法/","link":"","permalink":"http://mcer.win/2018/06/28/Ubuntu14-04上安装pip的方法/","excerpt":"","text":"Ubuntu14.04上安装pip的方法 ①12wget https://bootstrap.pypa.io/get-pip.py --no-check-certificatesudo python get-pip.py PS：1234567891011121314151617root@ubt:~# pip Traceback (most recent call last): File &quot;/usr/bin/pip&quot;, line 9, in load_entry_point(&apos;pip==1.5.4&apos;, &apos;console_scripts&apos;, &apos;pip&apos;)() File &quot;/usr/lib/python2.7/dist-packages/pkg_resources.py&quot;, line 351, in load_entry_point return get_distribution(dist).load_entry_point(group, name) File &quot;/usr/lib/python2.7/dist-packages/pkg_resources.py&quot;, line 2363, in load_entry_point return ep.load() File &quot;/usr/lib/python2.7/dist-packages/pkg_resources.py&quot;, line 2088, in load entry = __import__(self.module_name, globals(),globals(), [&apos;__name__&apos;]) File &quot;/usr/lib/python2.7/dist-packages/pip/__init__.py&quot;, line 11, in from pip.vcs import git, mercurial, subversion, bazaar # noqa File &quot;/usr/lib/python2.7/dist-packages/pip/vcs/mercurial.py&quot;, line 9, in from pip.download import path_to_url File &quot;/usr/lib/python2.7/dist-packages/pip/download.py&quot;, line 25, in from requests.compat import IncompleteReadImportError: cannot import name IncompleteRead 这是因为通过apt-get安装的pip版本太老了，老的pip版本依赖requests.compat.IncompleteRead，而在2.4.0版本的requests中已经移除了 requests.compat.IncompleteRead，解决方法是先卸载pip（命令为sudo apt-get remove python-pip），然后再用上面①的方法重新安装。 百度索得","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://mcer.win/tags/Linux/"},{"name":"配置","slug":"配置","permalink":"http://mcer.win/tags/配置/"}]},{"title":"Python--format的三种玩法","slug":"Python-format的三种玩法","date":"2018-06-28T08:20:43.000Z","updated":"2018-06-28T08:47:50.659Z","comments":true,"path":"2018/06/28/Python-format的三种玩法/","link":"","permalink":"http://mcer.win/2018/06/28/Python-format的三种玩法/","excerpt":"","text":"字符串str中的format()，用于格式化输出类似%s、%d 三种玩法： 123456789101112s = &apos;我叫&#123;&#125;，今年&#123;&#125;，爱好&#123;&#125;，再说一下我叫&#123;&#125;&apos;.format(&apos;NeNe&apos;,18,&apos;girl&apos;,&apos;NeNe&apos;)print(s)name = input(&apos;请输入名字：&apos;)s = &apos;我叫&#123;0&#125;，今年&#123;1&#125;，爱好&#123;2&#125;，再说一下我叫&#123;0&#125;&apos;.format(NeNe,18,&apos;girl&apos;)print(s)name = input(&apos;请输入名字：&apos;)age = input(&apos;请输入年龄：&apos;)hobby = input(&apos;请输入爱好：&apos;)s = &apos;我叫&#123;name&#125;，今年&#123;age&#125;，爱好&#123;hobby&#125;，再说一下我叫&#123;name&#125;&apos;.format(age=age,name=name,hobby=hobby)print(s) 来自老男孩9期day3 02视频","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"}]},{"title":"NeNe的日记","slug":"NeNe的日记","date":"2018-06-27T15:05:35.000Z","updated":"2018-06-28T08:47:47.941Z","comments":true,"path":"2018/06/27/NeNe的日记/","link":"","permalink":"http://mcer.win/2018/06/27/NeNe的日记/","excerpt":"","text":"总结一下： 首先折腾了两天 个人博客终于上线了。hexo博客系统+GitHub托管好处：静态，意味着安全，无需考虑数据库环境的部署不需要数据库也就轻便了很多，只要本地写好博客推到GitHub上就可以了 也是比较稳的了就是不知道以后文章多了 推送的时候不会太大导致降低效率 先用用看吧。 觉得可以再搞一个Linux服务器再搭个博客上去 同步推送两个域名 就当备用也行。顺便练手hexo+server的部署过程以上为YY 抽空再搞搞。····································另外每次git bash下12$ hexo d#推送之后老需要手动重新填写设置里面的域名 导致十分麻烦 12$ hexo g#生产静态文件 解决方法就是在本地网站根目录下新建一个名为‘CNAME’的文件 里面写上需要解析的域名即可，然后把‘CNAME’文件复制到 “\\public\\” 目录下面，然后再执行$ hexo d就可以了 ······································以上为博客搭建过程中后面碰到的问题 今天从新开始看老男孩的python教程具体资源为：老男孩全栈9期 已有1-9部分链接: https://pan.baidu.com/s/1_TPZasQUQgm8puZA0m-Hgw 密码: z3g1 睡前看了廖雪峰的JavaScript教程目测体感还不错明天就继续看啦看到这里过了： https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449917624134f5c4695b524e81a581ab5a222b05ec000","categories":[],"tags":[{"name":"日记","slug":"日记","permalink":"http://mcer.win/tags/日记/"},{"name":"计划","slug":"计划","permalink":"http://mcer.win/tags/计划/"}]},{"title":"python django web模块编程中的疑虑","slug":"python-django-web模块编程中的疑虑","date":"2018-06-27T07:39:29.000Z","updated":"2018-06-28T08:50:52.860Z","comments":true,"path":"2018/06/27/python-django-web模块编程中的疑虑/","link":"","permalink":"http://mcer.win/2018/06/27/python-django-web模块编程中的疑虑/","excerpt":"","text":"教程中的网页功能 列如：用户交易功能是在IDE中将某个单独功能 具体化成一个模块来写 1234567form xxx import xxxclass Xxxx(): xxx = xxx() aaa = aaa() .. ... 类似上面这样 的class类模块 最后将其串联调用整合到相关网页中 成为当前网页的一部分功能模块 应该是这样理解吧 还不知道咋去串联调用。。。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://mcer.win/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://mcer.win/tags/Django/"}]},{"title":"初步学习计划","slug":"初步学习计划","date":"2018-06-27T06:07:37.000Z","updated":"2018-06-27T06:44:05.091Z","comments":true,"path":"2018/06/27/初步学习计划/","link":"","permalink":"http://mcer.win/2018/06/27/初步学习计划/","excerpt":"","text":"学习计划 方向：web前端内容： 1、HTML5/CSS3/JavaScript 2、Angular.js/Vue.js/React/Node.js 3、Python3/Django/ 4、其它杂项另行记载 过程： 上面的①与③每天夜里看相关知识 ②白天看，抽空阅读任一一项框架，每项阅读半小时， 疑问一律都留到晚上，实操也留夜里。 关于python，以python为中心 重点学习，时间占比大，累了就换HTML相关内容继续学习 做好每天的学习笔记，睡前做好总结。 制定相关第二天的学习内容。 学习计划大体围绕以上规则实施。 还有相关工具的熟悉 VScode、Pycharm、Hexo、GitHub等先写这么多吧 想不出来了。","categories":[],"tags":[{"name":"计划","slug":"计划","permalink":"http://mcer.win/tags/计划/"}]},{"title":"Bootstrap模板样式网站","slug":"Bootstrap模板样式网站","date":"2018-06-27T04:37:45.000Z","updated":"2018-06-27T04:41:15.254Z","comments":true,"path":"2018/06/27/Bootstrap模板样式网站/","link":"","permalink":"http://mcer.win/2018/06/27/Bootstrap模板样式网站/","excerpt":"","text":"Bootstrap模板：https://html5up.net/这个网站提供了免费的响应式模板，觉得还可以。","categories":[],"tags":[{"name":"网页收藏","slug":"网页收藏","permalink":"http://mcer.win/tags/网页收藏/"}]},{"title":"配置SSH key","slug":"配置SSH-key","date":"2018-06-27T04:36:45.000Z","updated":"2018-06-28T08:49:29.209Z","comments":true,"path":"2018/06/27/配置SSH-key/","link":"","permalink":"http://mcer.win/2018/06/27/配置SSH-key/","excerpt":"","text":"git Bash 下执行1234ssh-keygen -t rsa -C &quot;·········@qq.com&quot;ssh -T git@github.com # 注意邮箱地址不用改git config --global user.name &quot;········&quot;// 你的github用户名，非昵称git config --global user.email &quot;········@qq.com&quot;// 填写你的github注册邮箱","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"http://mcer.win/tags/配置/"}]},{"title":"热到听般禅梵唱妙音","slug":"热到听般禅梵唱妙音","date":"2018-06-27T04:03:38.000Z","updated":"2018-06-27T05:04:16.861Z","comments":true,"path":"2018/06/27/热到听般禅梵唱妙音/","link":"","permalink":"http://mcer.win/2018/06/27/热到听般禅梵唱妙音/","excerpt":"","text":"","categories":[],"tags":[{"name":"闲","slug":"闲","permalink":"http://mcer.win/tags/闲/"}]}]}